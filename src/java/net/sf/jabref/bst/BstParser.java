// $ANTLR 3.4 C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g 2012-10-28 23:48:28
// Generated by ANTLR
package net.sf.jabref.bst;

import org.antlr.runtime.*;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;

import org.antlr.runtime.tree.*;


@SuppressWarnings({"all", "warnings", "unchecked"})
public class BstParser extends Parser {
    public static final String[] tokenNames = new String[] {
        "<invalid>", "<EOR>", "<DOWN>", "<UP>", "COMMANDS", "ENTRY", "EXECUTE", "FUNCTION", "IDENTIFIER", "IDLIST", "INTEGER", "INTEGERS", "ITERATE", "LETTER", "LINE_COMMENT", "MACRO", "NUMERAL", "QUOTED", "READ", "REVERSE", "SORT", "STACK", "STRING", "STRINGS", "WS", "'*'", "'+'", "'-'", "':='", "'<'", "'='", "'>'", "'{'", "'}'"
    };

    public static final int EOF=-1;
    public static final int T__25=25;
    public static final int T__26=26;
    public static final int T__27=27;
    public static final int T__28=28;
    public static final int T__29=29;
    public static final int T__30=30;
    public static final int T__31=31;
    public static final int T__32=32;
    public static final int T__33=33;
    public static final int COMMANDS=4;
    public static final int ENTRY=5;
    public static final int EXECUTE=6;
    public static final int FUNCTION=7;
    public static final int IDENTIFIER=8;
    public static final int IDLIST=9;
    public static final int INTEGER=10;
    public static final int INTEGERS=11;
    public static final int ITERATE=12;
    public static final int LETTER=13;
    public static final int LINE_COMMENT=14;
    public static final int MACRO=15;
    public static final int NUMERAL=16;
    public static final int QUOTED=17;
    public static final int READ=18;
    public static final int REVERSE=19;
    public static final int SORT=20;
    public static final int STACK=21;
    public static final int STRING=22;
    public static final int STRINGS=23;
    public static final int WS=24;

    // delegates
    public Parser[] getDelegates() {
        return new Parser[] {};
    }

    // delegators


    public BstParser(TokenStream input) {
        this(input, new RecognizerSharedState());
    }
    public BstParser(TokenStream input, RecognizerSharedState state) {
        super(input, state);
    }

protected TreeAdaptor adaptor = new CommonTreeAdaptor();

public void setTreeAdaptor(TreeAdaptor adaptor) {
    this.adaptor = adaptor;
}
public TreeAdaptor getTreeAdaptor() {
    return adaptor;
}
    public String[] getTokenNames() { return BstParser.tokenNames; }
    public String getGrammarFileName() { return "C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g"; }


    public static class program_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "program"
    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:22:1: program : ( commands )+ -> ^( COMMANDS ( commands )+ ) ;
    public final BstParser.program_return program() throws RecognitionException {
        BstParser.program_return retval = new BstParser.program_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        BstParser.commands_return commands1 =null;


        RewriteRuleSubtreeStream stream_commands=new RewriteRuleSubtreeStream(adaptor,"rule commands");
        try {
            // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:22:9: ( ( commands )+ -> ^( COMMANDS ( commands )+ ) )
            // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:22:11: ( commands )+
            {
            // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:22:11: ( commands )+
            int cnt1=0;
            loop1:
            do {
                int alt1=2;
                int LA1_0 = input.LA(1);

                if ( ((LA1_0 >= ENTRY && LA1_0 <= FUNCTION)||(LA1_0 >= INTEGERS && LA1_0 <= ITERATE)||LA1_0==MACRO||(LA1_0 >= READ && LA1_0 <= SORT)||LA1_0==STRINGS) ) {
                    alt1=1;
                }


                switch (alt1) {
            	case 1 :
            	    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:22:11: commands
            	    {
            	    pushFollow(FOLLOW_commands_in_program62);
            	    commands1=commands();

            	    state._fsp--;

            	    stream_commands.add(commands1.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt1 >= 1 ) break loop1;
                        EarlyExitException eee =
                            new EarlyExitException(1, input);
                        throw eee;
                }
                cnt1++;
            } while (true);


            // AST REWRITE
            // elements: commands
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 22:21: -> ^( COMMANDS ( commands )+ )
            {
                // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:22:24: ^( COMMANDS ( commands )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(COMMANDS, "COMMANDS")
                , root_1);

                if ( !(stream_commands.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_commands.hasNext() ) {
                    adaptor.addChild(root_1, stream_commands.nextTree());

                }
                stream_commands.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;

            }

            retval.stop = input.LT(-1);


            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "program"


    public static class commands_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "commands"
    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:24:1: commands : ( STRINGS ^ idList | INTEGERS ^ idList | FUNCTION ^ id stack | MACRO ^ id '{' ! STRING '}' !| READ ^| EXECUTE ^ '{' ! function '}' !| ITERATE ^ '{' ! function '}' !| REVERSE ^ '{' ! function '}' !| ENTRY ^ idList0 idList0 idList0 | SORT ^);
    public final BstParser.commands_return commands() throws RecognitionException {
        BstParser.commands_return retval = new BstParser.commands_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token STRINGS2=null;
        Token INTEGERS4=null;
        Token FUNCTION6=null;
        Token MACRO9=null;
        Token char_literal11=null;
        Token STRING12=null;
        Token char_literal13=null;
        Token READ14=null;
        Token EXECUTE15=null;
        Token char_literal16=null;
        Token char_literal18=null;
        Token ITERATE19=null;
        Token char_literal20=null;
        Token char_literal22=null;
        Token REVERSE23=null;
        Token char_literal24=null;
        Token char_literal26=null;
        Token ENTRY27=null;
        Token SORT31=null;
        BstParser.idList_return idList3 =null;

        BstParser.idList_return idList5 =null;

        BstParser.id_return id7 =null;

        BstParser.stack_return stack8 =null;

        BstParser.id_return id10 =null;

        BstParser.function_return function17 =null;

        BstParser.function_return function21 =null;

        BstParser.function_return function25 =null;

        BstParser.idList0_return idList028 =null;

        BstParser.idList0_return idList029 =null;

        BstParser.idList0_return idList030 =null;


        Object STRINGS2_tree=null;
        Object INTEGERS4_tree=null;
        Object FUNCTION6_tree=null;
        Object MACRO9_tree=null;
        Object char_literal11_tree=null;
        Object STRING12_tree=null;
        Object char_literal13_tree=null;
        Object READ14_tree=null;
        Object EXECUTE15_tree=null;
        Object char_literal16_tree=null;
        Object char_literal18_tree=null;
        Object ITERATE19_tree=null;
        Object char_literal20_tree=null;
        Object char_literal22_tree=null;
        Object REVERSE23_tree=null;
        Object char_literal24_tree=null;
        Object char_literal26_tree=null;
        Object ENTRY27_tree=null;
        Object SORT31_tree=null;

        try {
            // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:25:2: ( STRINGS ^ idList | INTEGERS ^ idList | FUNCTION ^ id stack | MACRO ^ id '{' ! STRING '}' !| READ ^| EXECUTE ^ '{' ! function '}' !| ITERATE ^ '{' ! function '}' !| REVERSE ^ '{' ! function '}' !| ENTRY ^ idList0 idList0 idList0 | SORT ^)
            int alt2=10;
            switch ( input.LA(1) ) {
            case STRINGS:
                {
                alt2=1;
                }
                break;
            case INTEGERS:
                {
                alt2=2;
                }
                break;
            case FUNCTION:
                {
                alt2=3;
                }
                break;
            case MACRO:
                {
                alt2=4;
                }
                break;
            case READ:
                {
                alt2=5;
                }
                break;
            case EXECUTE:
                {
                alt2=6;
                }
                break;
            case ITERATE:
                {
                alt2=7;
                }
                break;
            case REVERSE:
                {
                alt2=8;
                }
                break;
            case ENTRY:
                {
                alt2=9;
                }
                break;
            case SORT:
                {
                alt2=10;
                }
                break;
            default:
                NoViableAltException nvae =
                    new NoViableAltException("", 2, 0, input);

                throw nvae;

            }

            switch (alt2) {
                case 1 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:25:4: STRINGS ^ idList
                    {
                    root_0 = (Object)adaptor.nil();


                    STRINGS2=(Token)match(input,STRINGS,FOLLOW_STRINGS_in_commands82); 
                    STRINGS2_tree = 
                    (Object)adaptor.create(STRINGS2)
                    ;
                    root_0 = (Object)adaptor.becomeRoot(STRINGS2_tree, root_0);


                    pushFollow(FOLLOW_idList_in_commands85);
                    idList3=idList();

                    state._fsp--;

                    adaptor.addChild(root_0, idList3.getTree());

                    }
                    break;
                case 2 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:26:4: INTEGERS ^ idList
                    {
                    root_0 = (Object)adaptor.nil();


                    INTEGERS4=(Token)match(input,INTEGERS,FOLLOW_INTEGERS_in_commands90); 
                    INTEGERS4_tree = 
                    (Object)adaptor.create(INTEGERS4)
                    ;
                    root_0 = (Object)adaptor.becomeRoot(INTEGERS4_tree, root_0);


                    pushFollow(FOLLOW_idList_in_commands93);
                    idList5=idList();

                    state._fsp--;

                    adaptor.addChild(root_0, idList5.getTree());

                    }
                    break;
                case 3 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:27:4: FUNCTION ^ id stack
                    {
                    root_0 = (Object)adaptor.nil();


                    FUNCTION6=(Token)match(input,FUNCTION,FOLLOW_FUNCTION_in_commands98); 
                    FUNCTION6_tree = 
                    (Object)adaptor.create(FUNCTION6)
                    ;
                    root_0 = (Object)adaptor.becomeRoot(FUNCTION6_tree, root_0);


                    pushFollow(FOLLOW_id_in_commands101);
                    id7=id();

                    state._fsp--;

                    adaptor.addChild(root_0, id7.getTree());

                    pushFollow(FOLLOW_stack_in_commands103);
                    stack8=stack();

                    state._fsp--;

                    adaptor.addChild(root_0, stack8.getTree());

                    }
                    break;
                case 4 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:28:4: MACRO ^ id '{' ! STRING '}' !
                    {
                    root_0 = (Object)adaptor.nil();


                    MACRO9=(Token)match(input,MACRO,FOLLOW_MACRO_in_commands108); 
                    MACRO9_tree = 
                    (Object)adaptor.create(MACRO9)
                    ;
                    root_0 = (Object)adaptor.becomeRoot(MACRO9_tree, root_0);


                    pushFollow(FOLLOW_id_in_commands111);
                    id10=id();

                    state._fsp--;

                    adaptor.addChild(root_0, id10.getTree());

                    char_literal11=(Token)match(input,32,FOLLOW_32_in_commands113); 

                    STRING12=(Token)match(input,STRING,FOLLOW_STRING_in_commands116); 
                    STRING12_tree = 
                    (Object)adaptor.create(STRING12)
                    ;
                    adaptor.addChild(root_0, STRING12_tree);


                    char_literal13=(Token)match(input,33,FOLLOW_33_in_commands118); 

                    }
                    break;
                case 5 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:29:4: READ ^
                    {
                    root_0 = (Object)adaptor.nil();


                    READ14=(Token)match(input,READ,FOLLOW_READ_in_commands124); 
                    READ14_tree = 
                    (Object)adaptor.create(READ14)
                    ;
                    root_0 = (Object)adaptor.becomeRoot(READ14_tree, root_0);


                    }
                    break;
                case 6 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:30:4: EXECUTE ^ '{' ! function '}' !
                    {
                    root_0 = (Object)adaptor.nil();


                    EXECUTE15=(Token)match(input,EXECUTE,FOLLOW_EXECUTE_in_commands130); 
                    EXECUTE15_tree = 
                    (Object)adaptor.create(EXECUTE15)
                    ;
                    root_0 = (Object)adaptor.becomeRoot(EXECUTE15_tree, root_0);


                    char_literal16=(Token)match(input,32,FOLLOW_32_in_commands133); 

                    pushFollow(FOLLOW_function_in_commands136);
                    function17=function();

                    state._fsp--;

                    adaptor.addChild(root_0, function17.getTree());

                    char_literal18=(Token)match(input,33,FOLLOW_33_in_commands138); 

                    }
                    break;
                case 7 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:31:4: ITERATE ^ '{' ! function '}' !
                    {
                    root_0 = (Object)adaptor.nil();


                    ITERATE19=(Token)match(input,ITERATE,FOLLOW_ITERATE_in_commands144); 
                    ITERATE19_tree = 
                    (Object)adaptor.create(ITERATE19)
                    ;
                    root_0 = (Object)adaptor.becomeRoot(ITERATE19_tree, root_0);


                    char_literal20=(Token)match(input,32,FOLLOW_32_in_commands147); 

                    pushFollow(FOLLOW_function_in_commands150);
                    function21=function();

                    state._fsp--;

                    adaptor.addChild(root_0, function21.getTree());

                    char_literal22=(Token)match(input,33,FOLLOW_33_in_commands152); 

                    }
                    break;
                case 8 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:32:4: REVERSE ^ '{' ! function '}' !
                    {
                    root_0 = (Object)adaptor.nil();


                    REVERSE23=(Token)match(input,REVERSE,FOLLOW_REVERSE_in_commands158); 
                    REVERSE23_tree = 
                    (Object)adaptor.create(REVERSE23)
                    ;
                    root_0 = (Object)adaptor.becomeRoot(REVERSE23_tree, root_0);


                    char_literal24=(Token)match(input,32,FOLLOW_32_in_commands161); 

                    pushFollow(FOLLOW_function_in_commands164);
                    function25=function();

                    state._fsp--;

                    adaptor.addChild(root_0, function25.getTree());

                    char_literal26=(Token)match(input,33,FOLLOW_33_in_commands166); 

                    }
                    break;
                case 9 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:33:4: ENTRY ^ idList0 idList0 idList0
                    {
                    root_0 = (Object)adaptor.nil();


                    ENTRY27=(Token)match(input,ENTRY,FOLLOW_ENTRY_in_commands172); 
                    ENTRY27_tree = 
                    (Object)adaptor.create(ENTRY27)
                    ;
                    root_0 = (Object)adaptor.becomeRoot(ENTRY27_tree, root_0);


                    pushFollow(FOLLOW_idList0_in_commands175);
                    idList028=idList0();

                    state._fsp--;

                    adaptor.addChild(root_0, idList028.getTree());

                    pushFollow(FOLLOW_idList0_in_commands177);
                    idList029=idList0();

                    state._fsp--;

                    adaptor.addChild(root_0, idList029.getTree());

                    pushFollow(FOLLOW_idList0_in_commands179);
                    idList030=idList0();

                    state._fsp--;

                    adaptor.addChild(root_0, idList030.getTree());

                    }
                    break;
                case 10 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:34:4: SORT ^
                    {
                    root_0 = (Object)adaptor.nil();


                    SORT31=(Token)match(input,SORT,FOLLOW_SORT_in_commands184); 
                    SORT31_tree = 
                    (Object)adaptor.create(SORT31)
                    ;
                    root_0 = (Object)adaptor.becomeRoot(SORT31_tree, root_0);


                    }
                    break;

            }
            retval.stop = input.LT(-1);


            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "commands"


    public static class identifier_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "identifier"
    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:36:1: identifier : IDENTIFIER ;
    public final BstParser.identifier_return identifier() throws RecognitionException {
        BstParser.identifier_return retval = new BstParser.identifier_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token IDENTIFIER32=null;

        Object IDENTIFIER32_tree=null;

        try {
            // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:37:2: ( IDENTIFIER )
            // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:37:4: IDENTIFIER
            {
            root_0 = (Object)adaptor.nil();


            IDENTIFIER32=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_identifier195); 
            IDENTIFIER32_tree = 
            (Object)adaptor.create(IDENTIFIER32)
            ;
            adaptor.addChild(root_0, IDENTIFIER32_tree);


            }

            retval.stop = input.LT(-1);


            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "identifier"


    public static class id_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "id"
    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:39:1: id : '{' ! identifier '}' !;
    public final BstParser.id_return id() throws RecognitionException {
        BstParser.id_return retval = new BstParser.id_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token char_literal33=null;
        Token char_literal35=null;
        BstParser.identifier_return identifier34 =null;


        Object char_literal33_tree=null;
        Object char_literal35_tree=null;

        try {
            // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:40:2: ( '{' ! identifier '}' !)
            // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:40:4: '{' ! identifier '}' !
            {
            root_0 = (Object)adaptor.nil();


            char_literal33=(Token)match(input,32,FOLLOW_32_in_id205); 

            pushFollow(FOLLOW_identifier_in_id208);
            identifier34=identifier();

            state._fsp--;

            adaptor.addChild(root_0, identifier34.getTree());

            char_literal35=(Token)match(input,33,FOLLOW_33_in_id210); 

            }

            retval.stop = input.LT(-1);


            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "id"


    public static class idList_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "idList"
    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:42:1: idList : '{' ( identifier )+ '}' -> ^( IDLIST ( identifier )+ ) ;
    public final BstParser.idList_return idList() throws RecognitionException {
        BstParser.idList_return retval = new BstParser.idList_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token char_literal36=null;
        Token char_literal38=null;
        BstParser.identifier_return identifier37 =null;


        Object char_literal36_tree=null;
        Object char_literal38_tree=null;
        RewriteRuleTokenStream stream_32=new RewriteRuleTokenStream(adaptor,"token 32");
        RewriteRuleTokenStream stream_33=new RewriteRuleTokenStream(adaptor,"token 33");
        RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
        try {
            // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:43:2: ( '{' ( identifier )+ '}' -> ^( IDLIST ( identifier )+ ) )
            // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:43:4: '{' ( identifier )+ '}'
            {
            char_literal36=(Token)match(input,32,FOLLOW_32_in_idList222);  
            stream_32.add(char_literal36);


            // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:43:8: ( identifier )+
            int cnt3=0;
            loop3:
            do {
                int alt3=2;
                int LA3_0 = input.LA(1);

                if ( (LA3_0==IDENTIFIER) ) {
                    alt3=1;
                }


                switch (alt3) {
            	case 1 :
            	    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:43:8: identifier
            	    {
            	    pushFollow(FOLLOW_identifier_in_idList224);
            	    identifier37=identifier();

            	    state._fsp--;

            	    stream_identifier.add(identifier37.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt3 >= 1 ) break loop3;
                        EarlyExitException eee =
                            new EarlyExitException(3, input);
                        throw eee;
                }
                cnt3++;
            } while (true);


            char_literal38=(Token)match(input,33,FOLLOW_33_in_idList227);  
            stream_33.add(char_literal38);


            // AST REWRITE
            // elements: identifier
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 43:24: -> ^( IDLIST ( identifier )+ )
            {
                // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:43:27: ^( IDLIST ( identifier )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(IDLIST, "IDLIST")
                , root_1);

                if ( !(stream_identifier.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_identifier.hasNext() ) {
                    adaptor.addChild(root_1, stream_identifier.nextTree());

                }
                stream_identifier.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;

            }

            retval.stop = input.LT(-1);


            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "idList"


    public static class idList0_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "idList0"
    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:45:1: idList0 : '{' ( identifier )* '}' -> ^( IDLIST ( identifier )* ) ;
    public final BstParser.idList0_return idList0() throws RecognitionException {
        BstParser.idList0_return retval = new BstParser.idList0_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token char_literal39=null;
        Token char_literal41=null;
        BstParser.identifier_return identifier40 =null;


        Object char_literal39_tree=null;
        Object char_literal41_tree=null;
        RewriteRuleTokenStream stream_32=new RewriteRuleTokenStream(adaptor,"token 32");
        RewriteRuleTokenStream stream_33=new RewriteRuleTokenStream(adaptor,"token 33");
        RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
        try {
            // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:46:2: ( '{' ( identifier )* '}' -> ^( IDLIST ( identifier )* ) )
            // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:46:4: '{' ( identifier )* '}'
            {
            char_literal39=(Token)match(input,32,FOLLOW_32_in_idList0247);  
            stream_32.add(char_literal39);


            // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:46:8: ( identifier )*
            loop4:
            do {
                int alt4=2;
                int LA4_0 = input.LA(1);

                if ( (LA4_0==IDENTIFIER) ) {
                    alt4=1;
                }


                switch (alt4) {
            	case 1 :
            	    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:46:8: identifier
            	    {
            	    pushFollow(FOLLOW_identifier_in_idList0249);
            	    identifier40=identifier();

            	    state._fsp--;

            	    stream_identifier.add(identifier40.getTree());

            	    }
            	    break;

            	default :
            	    break loop4;
                }
            } while (true);


            char_literal41=(Token)match(input,33,FOLLOW_33_in_idList0252);  
            stream_33.add(char_literal41);


            // AST REWRITE
            // elements: identifier
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 46:24: -> ^( IDLIST ( identifier )* )
            {
                // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:46:27: ^( IDLIST ( identifier )* )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(IDLIST, "IDLIST")
                , root_1);

                // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:46:36: ( identifier )*
                while ( stream_identifier.hasNext() ) {
                    adaptor.addChild(root_1, stream_identifier.nextTree());

                }
                stream_identifier.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;

            }

            retval.stop = input.LT(-1);


            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "idList0"


    public static class function_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "function"
    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:48:1: function : ( '<' | '>' | '=' | '+' | '-' | ':=' | '*' | identifier );
    public final BstParser.function_return function() throws RecognitionException {
        BstParser.function_return retval = new BstParser.function_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token char_literal42=null;
        Token char_literal43=null;
        Token char_literal44=null;
        Token char_literal45=null;
        Token char_literal46=null;
        Token string_literal47=null;
        Token char_literal48=null;
        BstParser.identifier_return identifier49 =null;


        Object char_literal42_tree=null;
        Object char_literal43_tree=null;
        Object char_literal44_tree=null;
        Object char_literal45_tree=null;
        Object char_literal46_tree=null;
        Object string_literal47_tree=null;
        Object char_literal48_tree=null;

        try {
            // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:49:2: ( '<' | '>' | '=' | '+' | '-' | ':=' | '*' | identifier )
            int alt5=8;
            switch ( input.LA(1) ) {
            case 29:
                {
                alt5=1;
                }
                break;
            case 31:
                {
                alt5=2;
                }
                break;
            case 30:
                {
                alt5=3;
                }
                break;
            case 26:
                {
                alt5=4;
                }
                break;
            case 27:
                {
                alt5=5;
                }
                break;
            case 28:
                {
                alt5=6;
                }
                break;
            case 25:
                {
                alt5=7;
                }
                break;
            case IDENTIFIER:
                {
                alt5=8;
                }
                break;
            default:
                NoViableAltException nvae =
                    new NoViableAltException("", 5, 0, input);

                throw nvae;

            }

            switch (alt5) {
                case 1 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:49:4: '<'
                    {
                    root_0 = (Object)adaptor.nil();


                    char_literal42=(Token)match(input,29,FOLLOW_29_in_function271); 
                    char_literal42_tree = 
                    (Object)adaptor.create(char_literal42)
                    ;
                    adaptor.addChild(root_0, char_literal42_tree);


                    }
                    break;
                case 2 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:49:10: '>'
                    {
                    root_0 = (Object)adaptor.nil();


                    char_literal43=(Token)match(input,31,FOLLOW_31_in_function275); 
                    char_literal43_tree = 
                    (Object)adaptor.create(char_literal43)
                    ;
                    adaptor.addChild(root_0, char_literal43_tree);


                    }
                    break;
                case 3 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:49:16: '='
                    {
                    root_0 = (Object)adaptor.nil();


                    char_literal44=(Token)match(input,30,FOLLOW_30_in_function279); 
                    char_literal44_tree = 
                    (Object)adaptor.create(char_literal44)
                    ;
                    adaptor.addChild(root_0, char_literal44_tree);


                    }
                    break;
                case 4 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:49:22: '+'
                    {
                    root_0 = (Object)adaptor.nil();


                    char_literal45=(Token)match(input,26,FOLLOW_26_in_function283); 
                    char_literal45_tree = 
                    (Object)adaptor.create(char_literal45)
                    ;
                    adaptor.addChild(root_0, char_literal45_tree);


                    }
                    break;
                case 5 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:49:28: '-'
                    {
                    root_0 = (Object)adaptor.nil();


                    char_literal46=(Token)match(input,27,FOLLOW_27_in_function287); 
                    char_literal46_tree = 
                    (Object)adaptor.create(char_literal46)
                    ;
                    adaptor.addChild(root_0, char_literal46_tree);


                    }
                    break;
                case 6 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:49:34: ':='
                    {
                    root_0 = (Object)adaptor.nil();


                    string_literal47=(Token)match(input,28,FOLLOW_28_in_function291); 
                    string_literal47_tree = 
                    (Object)adaptor.create(string_literal47)
                    ;
                    adaptor.addChild(root_0, string_literal47_tree);


                    }
                    break;
                case 7 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:49:41: '*'
                    {
                    root_0 = (Object)adaptor.nil();


                    char_literal48=(Token)match(input,25,FOLLOW_25_in_function295); 
                    char_literal48_tree = 
                    (Object)adaptor.create(char_literal48)
                    ;
                    adaptor.addChild(root_0, char_literal48_tree);


                    }
                    break;
                case 8 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:49:47: identifier
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_identifier_in_function299);
                    identifier49=identifier();

                    state._fsp--;

                    adaptor.addChild(root_0, identifier49.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "function"


    public static class stack_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "stack"
    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:51:1: stack : '{' ( stackitem )+ '}' -> ^( STACK ( stackitem )+ ) ;
    public final BstParser.stack_return stack() throws RecognitionException {
        BstParser.stack_return retval = new BstParser.stack_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token char_literal50=null;
        Token char_literal52=null;
        BstParser.stackitem_return stackitem51 =null;


        Object char_literal50_tree=null;
        Object char_literal52_tree=null;
        RewriteRuleTokenStream stream_32=new RewriteRuleTokenStream(adaptor,"token 32");
        RewriteRuleTokenStream stream_33=new RewriteRuleTokenStream(adaptor,"token 33");
        RewriteRuleSubtreeStream stream_stackitem=new RewriteRuleSubtreeStream(adaptor,"rule stackitem");
        try {
            // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:52:2: ( '{' ( stackitem )+ '}' -> ^( STACK ( stackitem )+ ) )
            // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:52:4: '{' ( stackitem )+ '}'
            {
            char_literal50=(Token)match(input,32,FOLLOW_32_in_stack310);  
            stream_32.add(char_literal50);


            // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:52:8: ( stackitem )+
            int cnt6=0;
            loop6:
            do {
                int alt6=2;
                int LA6_0 = input.LA(1);

                if ( (LA6_0==IDENTIFIER||LA6_0==INTEGER||LA6_0==QUOTED||LA6_0==STRING||(LA6_0 >= 25 && LA6_0 <= 32)) ) {
                    alt6=1;
                }


                switch (alt6) {
            	case 1 :
            	    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:52:8: stackitem
            	    {
            	    pushFollow(FOLLOW_stackitem_in_stack312);
            	    stackitem51=stackitem();

            	    state._fsp--;

            	    stream_stackitem.add(stackitem51.getTree());

            	    }
            	    break;

            	default :
            	    if ( cnt6 >= 1 ) break loop6;
                        EarlyExitException eee =
                            new EarlyExitException(6, input);
                        throw eee;
                }
                cnt6++;
            } while (true);


            char_literal52=(Token)match(input,33,FOLLOW_33_in_stack315);  
            stream_33.add(char_literal52);


            // AST REWRITE
            // elements: stackitem
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            retval.tree = root_0;
            RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

            root_0 = (Object)adaptor.nil();
            // 52:23: -> ^( STACK ( stackitem )+ )
            {
                // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:52:26: ^( STACK ( stackitem )+ )
                {
                Object root_1 = (Object)adaptor.nil();
                root_1 = (Object)adaptor.becomeRoot(
                (Object)adaptor.create(STACK, "STACK")
                , root_1);

                if ( !(stream_stackitem.hasNext()) ) {
                    throw new RewriteEarlyExitException();
                }
                while ( stream_stackitem.hasNext() ) {
                    adaptor.addChild(root_1, stream_stackitem.nextTree());

                }
                stream_stackitem.reset();

                adaptor.addChild(root_0, root_1);
                }

            }


            retval.tree = root_0;

            }

            retval.stop = input.LT(-1);


            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "stack"


    public static class stackitem_return extends ParserRuleReturnScope {
        Object tree;
        public Object getTree() { return tree; }
    };


    // $ANTLR start "stackitem"
    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:54:1: stackitem : ( function | STRING | INTEGER | QUOTED | stack );
    public final BstParser.stackitem_return stackitem() throws RecognitionException {
        BstParser.stackitem_return retval = new BstParser.stackitem_return();
        retval.start = input.LT(1);


        Object root_0 = null;

        Token STRING54=null;
        Token INTEGER55=null;
        Token QUOTED56=null;
        BstParser.function_return function53 =null;

        BstParser.stack_return stack57 =null;


        Object STRING54_tree=null;
        Object INTEGER55_tree=null;
        Object QUOTED56_tree=null;

        try {
            // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:55:2: ( function | STRING | INTEGER | QUOTED | stack )
            int alt7=5;
            switch ( input.LA(1) ) {
            case IDENTIFIER:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
                {
                alt7=1;
                }
                break;
            case STRING:
                {
                alt7=2;
                }
                break;
            case INTEGER:
                {
                alt7=3;
                }
                break;
            case QUOTED:
                {
                alt7=4;
                }
                break;
            case 32:
                {
                alt7=5;
                }
                break;
            default:
                NoViableAltException nvae =
                    new NoViableAltException("", 7, 0, input);

                throw nvae;

            }

            switch (alt7) {
                case 1 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:55:4: function
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_function_in_stackitem334);
                    function53=function();

                    state._fsp--;

                    adaptor.addChild(root_0, function53.getTree());

                    }
                    break;
                case 2 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:56:4: STRING
                    {
                    root_0 = (Object)adaptor.nil();


                    STRING54=(Token)match(input,STRING,FOLLOW_STRING_in_stackitem339); 
                    STRING54_tree = 
                    (Object)adaptor.create(STRING54)
                    ;
                    adaptor.addChild(root_0, STRING54_tree);


                    }
                    break;
                case 3 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:57:4: INTEGER
                    {
                    root_0 = (Object)adaptor.nil();


                    INTEGER55=(Token)match(input,INTEGER,FOLLOW_INTEGER_in_stackitem345); 
                    INTEGER55_tree = 
                    (Object)adaptor.create(INTEGER55)
                    ;
                    adaptor.addChild(root_0, INTEGER55_tree);


                    }
                    break;
                case 4 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:58:4: QUOTED
                    {
                    root_0 = (Object)adaptor.nil();


                    QUOTED56=(Token)match(input,QUOTED,FOLLOW_QUOTED_in_stackitem351); 
                    QUOTED56_tree = 
                    (Object)adaptor.create(QUOTED56)
                    ;
                    adaptor.addChild(root_0, QUOTED56_tree);


                    }
                    break;
                case 5 :
                    // C:\\git-repos\\jabref\\jabref\\src\\java\\net\\sf\\jabref\\bst\\Bst.g:59:4: stack
                    {
                    root_0 = (Object)adaptor.nil();


                    pushFollow(FOLLOW_stack_in_stackitem356);
                    stack57=stack();

                    state._fsp--;

                    adaptor.addChild(root_0, stack57.getTree());

                    }
                    break;

            }
            retval.stop = input.LT(-1);


            retval.tree = (Object)adaptor.rulePostProcessing(root_0);
            adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
        	// do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "stackitem"

    // Delegated rules


 

    public static final BitSet FOLLOW_commands_in_program62 = new BitSet(new long[]{0x00000000009C98E2L});
    public static final BitSet FOLLOW_STRINGS_in_commands82 = new BitSet(new long[]{0x0000000100000000L});
    public static final BitSet FOLLOW_idList_in_commands85 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTEGERS_in_commands90 = new BitSet(new long[]{0x0000000100000000L});
    public static final BitSet FOLLOW_idList_in_commands93 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FUNCTION_in_commands98 = new BitSet(new long[]{0x0000000100000000L});
    public static final BitSet FOLLOW_id_in_commands101 = new BitSet(new long[]{0x0000000100000000L});
    public static final BitSet FOLLOW_stack_in_commands103 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_MACRO_in_commands108 = new BitSet(new long[]{0x0000000100000000L});
    public static final BitSet FOLLOW_id_in_commands111 = new BitSet(new long[]{0x0000000100000000L});
    public static final BitSet FOLLOW_32_in_commands113 = new BitSet(new long[]{0x0000000000400000L});
    public static final BitSet FOLLOW_STRING_in_commands116 = new BitSet(new long[]{0x0000000200000000L});
    public static final BitSet FOLLOW_33_in_commands118 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_READ_in_commands124 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_EXECUTE_in_commands130 = new BitSet(new long[]{0x0000000100000000L});
    public static final BitSet FOLLOW_32_in_commands133 = new BitSet(new long[]{0x00000000FE000100L});
    public static final BitSet FOLLOW_function_in_commands136 = new BitSet(new long[]{0x0000000200000000L});
    public static final BitSet FOLLOW_33_in_commands138 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ITERATE_in_commands144 = new BitSet(new long[]{0x0000000100000000L});
    public static final BitSet FOLLOW_32_in_commands147 = new BitSet(new long[]{0x00000000FE000100L});
    public static final BitSet FOLLOW_function_in_commands150 = new BitSet(new long[]{0x0000000200000000L});
    public static final BitSet FOLLOW_33_in_commands152 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_REVERSE_in_commands158 = new BitSet(new long[]{0x0000000100000000L});
    public static final BitSet FOLLOW_32_in_commands161 = new BitSet(new long[]{0x00000000FE000100L});
    public static final BitSet FOLLOW_function_in_commands164 = new BitSet(new long[]{0x0000000200000000L});
    public static final BitSet FOLLOW_33_in_commands166 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ENTRY_in_commands172 = new BitSet(new long[]{0x0000000100000000L});
    public static final BitSet FOLLOW_idList0_in_commands175 = new BitSet(new long[]{0x0000000100000000L});
    public static final BitSet FOLLOW_idList0_in_commands177 = new BitSet(new long[]{0x0000000100000000L});
    public static final BitSet FOLLOW_idList0_in_commands179 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SORT_in_commands184 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENTIFIER_in_identifier195 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_32_in_id205 = new BitSet(new long[]{0x0000000000000100L});
    public static final BitSet FOLLOW_identifier_in_id208 = new BitSet(new long[]{0x0000000200000000L});
    public static final BitSet FOLLOW_33_in_id210 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_32_in_idList222 = new BitSet(new long[]{0x0000000000000100L});
    public static final BitSet FOLLOW_identifier_in_idList224 = new BitSet(new long[]{0x0000000200000100L});
    public static final BitSet FOLLOW_33_in_idList227 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_32_in_idList0247 = new BitSet(new long[]{0x0000000200000100L});
    public static final BitSet FOLLOW_identifier_in_idList0249 = new BitSet(new long[]{0x0000000200000100L});
    public static final BitSet FOLLOW_33_in_idList0252 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_29_in_function271 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_31_in_function275 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_30_in_function279 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_26_in_function283 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_27_in_function287 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_28_in_function291 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_25_in_function295 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_identifier_in_function299 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_32_in_stack310 = new BitSet(new long[]{0x00000001FE420500L});
    public static final BitSet FOLLOW_stackitem_in_stack312 = new BitSet(new long[]{0x00000003FE420500L});
    public static final BitSet FOLLOW_33_in_stack315 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_function_in_stackitem334 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_STRING_in_stackitem339 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTEGER_in_stackitem345 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_QUOTED_in_stackitem351 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_stack_in_stackitem356 = new BitSet(new long[]{0x0000000000000002L});

}